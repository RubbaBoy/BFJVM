package com.uddernetworks.bfjvm.bytecode.chunks.methods;

public class Instruction {
    public static final int aaload = 0x32; // load onto the stack a reference from an array
    public static final int aastore = 0x53; // store a reference in an array
    public static final int aconst_null = 0x01; // push a null reference onto the stack
    public static final int aload = 0x19; // load a reference onto the stack from a local variable #index
    public static final int aload_0 = 0x2a; // load a reference onto the stack from local variable 0
    public static final int aload_1 = 0x2b; // load a reference onto the stack from local variable 1
    public static final int aload_2 = 0x2c; // load a reference onto the stack from local variable 2
    public static final int aload_3 = 0x2d; // load a reference onto the stack from local variable 3
    public static final int anewarray = 0xbd; // create a new array of references of length count and component type identified by the class reference index (indexbyte1 << 8 + indexbyte2) in the constant pool
    public static final int areturn = 0xb0; // return a reference from a method
    public static final int arraylength = 0xbe; // get the length of an array
    public static final int astore = 0x3a; // store a reference into a local variable #index
    public static final int astore_0 = 0x4b; // store a reference into local variable 0
    public static final int astore_1 = 0x4c; // store a reference into local variable 1
    public static final int astore_2 = 0x4d; // store a reference into local variable 2
    public static final int astore_3 = 0x4e; // store a reference into local variable 3
    public static final int athrow = 0xbf; // throws an error or exception (notice that the rest of the stack is cleared, leaving only a reference to the Throwable)
    public static final int baload = 0x33; // load a byte or Boolean value from an array
    public static final int bastore = 0x54; // store a byte or Boolean value into an array
    public static final int bipush = 0x10; // push a byte onto the stack as an integer value
    public static final int breakpoint = 0xca; // reserved for breakpoints in Java debuggers; should not appear in any class file
    public static final int caload = 0x34; // load a char from an array
    public static final int castore = 0x55; // store a char into an array
    public static final int checkcast = 0xc0; // checks whether an objectref is of a certain type, the class reference of which is in the constant pool at index (indexbyte1 << 8 + indexbyte2)
    public static final int d2f = 0x90; // convert a double to a float
    public static final int d2i = 0x8e; // convert a double to an int
    public static final int d2l = 0x8f; // convert a double to a long
    public static final int dadd = 0x63; // add two doubles
    public static final int daload = 0x31; // load a double from an array
    public static final int dastore = 0x52; // store a double into an array
    public static final int dcmpg = 0x98; // compare two doubles
    public static final int dcmpl = 0x97; // compare two doubles
    public static final int dconst_0 = 0x0e; // push the constant 0.0 (a double) onto the stack
    public static final int dconst_1 = 0x0f; // push the constant 1.0 (a double) onto the stack
    public static final int ddiv = 0x6f; // divide two doubles
    public static final int dload = 0x18; // load a double value from a local variable #index
    public static final int dload_0 = 0x26; // load a double from local variable 0
    public static final int dload_1 = 0x27; // load a double from local variable 1
    public static final int dload_2 = 0x28; // load a double from local variable 2
    public static final int dload_3 = 0x29; // load a double from local variable 3
    public static final int dmul = 0x6b; // multiply two doubles
    public static final int dneg = 0x77; // negate a double
    public static final int drem = 0x73; // get the remainder from a division between two doubles
    public static final int dreturn = 0xaf; // return a double from a method
    public static final int dstore = 0x39; // store a double value into a local variable #index
    public static final int dstore_0 = 0x47; // store a double into local variable 0
    public static final int dstore_1 = 0x48; // store a double into local variable 1
    public static final int dstore_2 = 0x49; // store a double into local variable 2
    public static final int dstore_3 = 0x4a; // store a double into local variable 3
    public static final int dsub = 0x67; // subtract a double from another
    public static final int dup = 0x59; // duplicate the value on top of the stack
    public static final int dup_x1 = 0x5a; // insert a copy of the top value into the stack two values from the top. value1 and value2 must not be of the type double or long.
    public static final int dup_x2 = 0x5b; // insert a copy of the top value into the stack two (if value2 is double or long it takes up the entry of value3, too) or three values (if value2 is neither double nor long) from the top
    public static final int dup2 = 0x5c; // duplicate top two stack words (two values, if value1 is not double nor long; a single value, if value1 is double or long)
    public static final int dup2_x1 = 0x5d; // duplicate two words and insert beneath third word (see explanation above)
    public static final int dup2_x2 = 0x5e; // duplicate two words and insert beneath fourth word
    public static final int f2d = 0x8d; // convert a float to a double
    public static final int f2i = 0x8b; // convert a float to an int
    public static final int f2l = 0x8c; // convert a float to a long
    public static final int fadd = 0x62; // add two floats
    public static final int faload = 0x30; // load a float from an array
    public static final int fastore = 0x51; // store a float in an array
    public static final int fcmpg = 0x96; // compare two floats
    public static final int fcmpl = 0x95; // compare two floats
    public static final int fconst_0 = 0x0b; // push 0.0f on the stack
    public static final int fconst_1 = 0x0c; // push 1.0f on the stack
    public static final int fconst_2 = 0x0d; // push 2.0f on the stack
    public static final int fdiv = 0x6e; // divide two floats
    public static final int fload = 0x17; // load a float value from a local variable #index
    public static final int fload_0 = 0x22; // load a float value from local variable 0
    public static final int fload_1 = 0x23; // load a float value from local variable 1
    public static final int fload_2 = 0x24; // load a float value from local variable 2
    public static final int fload_3 = 0x25; // load a float value from local variable 3
    public static final int fmul = 0x6a; // multiply two floats
    public static final int fneg = 0x76; // negate a float
    public static final int frem = 0x72; // get the remainder from a division between two floats
    public static final int freturn = 0xae; // return a float
    public static final int fstore = 0x38; // store a float value into a local variable #index
    public static final int fstore_0 = 0x43; // store a float value into local variable 0
    public static final int fstore_1 = 0x44; // store a float value into local variable 1
    public static final int fstore_2 = 0x45; // store a float value into local variable 2
    public static final int fstore_3 = 0x46; // store a float value into local variable 3
    public static final int fsub = 0x66; // subtract two floats
    public static final int getfield = 0xb4; // get a field value of an object objectref, where the field is identified by field reference in the constant pool index (indexbyte1 << 8 + indexbyte2)
    public static final int getstatic = 0xb2; // get a static field value of a class, where the field is identified by field reference in the constant pool index (indexbyte1 << 8 + indexbyte2)
    public static final int _goto = 0xa7; // goes to another instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int goto_w = 0xc8; // goes to another instruction at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4)
    public static final int i2b = 0x91; // convert an int into a byte
    public static final int i2c = 0x92; // convert an int into a character
    public static final int i2d = 0x87; // convert an int into a double
    public static final int i2f = 0x86; // convert an int into a float
    public static final int i2l = 0x85; // convert an int into a long
    public static final int i2s = 0x93; // convert an int into a short
    public static final int iadd = 0x60; // add two ints
    public static final int iaload = 0x2e; // load an int from an array
    public static final int iand = 0x7e; // perform a bitwise AND on two integers
    public static final int iastore = 0x4f; // store an int into an array
    public static final int iconst_m1 = 0x02; // load the int value −1 onto the stack
    public static final int iconst_0 = 0x03; // load the int value 0 onto the stack
    public static final int iconst_1 = 0x04; // load the int value 1 onto the stack
    public static final int iconst_2 = 0x05; // load the int value 2 onto the stack
    public static final int iconst_3 = 0x06; // load the int value 3 onto the stack
    public static final int iconst_4 = 0x07; // load the int value 4 onto the stack
    public static final int iconst_5 = 0x08; // load the int value 5 onto the stack
    public static final int idiv = 0x6c; // divide two integers
    public static final int if_acmpeq = 0xa5; // if references are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int if_acmpne = 0xa6; // if references are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int if_icmpeq = 0x9f; // if ints are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int if_icmpge = 0xa2; // if value1 is greater than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int if_icmpgt = 0xa3; // if value1 is greater than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int if_icmple = 0xa4; // if value1 is less than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int if_icmplt = 0xa1; // if value1 is less than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int if_icmpne = 0xa0; // if ints are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int ifeq = 0x99; // if value is 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int ifge = 0x9c; // if value is greater than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int ifgt = 0x9d; // if value is greater than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int ifle = 0x9e; // if value is less than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int iflt = 0x9b; // if value is less than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int ifne = 0x9a; // if value is not 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int ifnonnull = 0xc7; // if value is not null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int ifnull = 0xc6; // if value is null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    public static final int iinc = 0x84; // increment local variable #index by signed byte const
    public static final int iload = 0x15; // load an int value from a local variable #index
    public static final int iload_0 = 0x1a; // load an int value from local variable 0
    public static final int iload_1 = 0x1b; // load an int value from local variable 1
    public static final int iload_2 = 0x1c; // load an int value from local variable 2
    public static final int iload_3 = 0x1d; // load an int value from local variable 3
    public static final int impdep1 = 0xfe; // reserved for implementation-dependent operations within debuggers; should not appear in any class file
    public static final int impdep2 = 0xff; // reserved for implementation-dependent operations within debuggers; should not appear in any class file
    public static final int imul = 0x68; // multiply two integers
    public static final int ineg = 0x74; // negate int
    public static final int _instanceof = 0xc1; // determines if an object objectref is of a given type, identified by class reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    public static final int invokedynamic = 0xba; // invokes a dynamic method and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    public static final int invokeinterface = 0xb9; // invokes an interface method on object objectref and puts the result on the stack (might be void); the interface method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    public static final int invokespecial = 0xb7; // invoke instance method on object objectref and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    public static final int invokestatic = 0xb8; // invoke a static method and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    public static final int invokevirtual = 0xb6; // invoke virtual method on object objectref and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    public static final int ior = 0x80; // bitwise int OR
    public static final int irem = 0x70; // logical int remainder
    public static final int ireturn = 0xac; // return an integer from a method
    public static final int ishl = 0x78; // int shift left
    public static final int ishr = 0x7a; // int arithmetic shift right
    public static final int istore = 0x36; // store int value into variable #index
    public static final int istore_0 = 0x3b; // store int value into variable 0
    public static final int istore_1 = 0x3c; // store int value into variable 1
    public static final int istore_2 = 0x3d; // store int value into variable 2
    public static final int istore_3 = 0x3e; // store int value into variable 3
    public static final int isub = 0x64; // int subtract
    public static final int iushr = 0x7c; // int logical shift right
    public static final int ixor = 0x82; // int xor
    public static final int jsr = 0xa8; // jump to subroutine at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2) and place the return address on the stack
    public static final int jsr_w = 0xc9; // jump to subroutine at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4) and place the return address on the stack
    public static final int l2d = 0x8a; // convert a long to a double
    public static final int l2f = 0x89; // convert a long to a float
    public static final int l2i = 0x88; // convert a long to a int
    public static final int ladd = 0x61; // add two longs
    public static final int laload = 0x2f; // load a long from an array
    public static final int land = 0x7f; // bitwise AND of two longs
    public static final int lastore = 0x50; // store a long to an array
    public static final int lcmp = 0x94; // push 0 if the two longs are the same, 1 if value1 is greater than value2, -1 otherwise
    public static final int lconst_0 = 0x09; // push 0L (the number zero with type long) onto the stack
    public static final int lconst_1 = 0x0a; // push 1L (the number one with type long) onto the stack
    public static final int ldc = 0x12; // push a constant #index from a constant pool (String, int, float, Class, java.lang.invoke.MethodType, java.lang.invoke.MethodHandle, or a dynamically-computed constant) onto the stack
    public static final int ldc_w = 0x13; // push a constant #index from a constant pool (String, int, float, Class, java.lang.invoke.MethodType, java.lang.invoke.MethodHandle, or a dynamically-computed constant) onto the stack (wide index is constructed as indexbyte1 << 8 + indexbyte2)
    public static final int ldc2_w = 0x14; // push a constant #index from a constant pool (double, long, or a dynamically-computed constant) onto the stack (wide index is constructed as indexbyte1 << 8 + indexbyte2)
    public static final int ldiv = 0x6d; // divide two longs
    public static final int lload = 0x16; // load a long value from a local variable #index
    public static final int lload_0 = 0x1e; // load a long value from a local variable 0
    public static final int lload_1 = 0x1f; // load a long value from a local variable 1
    public static final int lload_2 = 0x20; // load a long value from a local variable 2
    public static final int lload_3 = 0x21; // load a long value from a local variable 3
    public static final int lmul = 0x69; // multiply two longs
    public static final int lneg = 0x75; // negate a long
    public static final int lookupswitch = 0xab; // a target address is looked up from a table using a key and execution continues from the instruction at that address
    public static final int lor = 0x81; // bitwise OR of two longs
    public static final int lrem = 0x71; // remainder of division of two longs
    public static final int lreturn = 0xad; // return a long value
    public static final int lshl = 0x79; // bitwise shift left of a long value1 by int value2 positions
    public static final int lshr = 0x7b; // bitwise shift right of a long value1 by int value2 positions
    public static final int lstore = 0x37; // store a long value in a local variable #index
    public static final int lstore_0 = 0x3f; // store a long value in a local variable 0
    public static final int lstore_1 = 0x40; // store a long value in a local variable 1
    public static final int lstore_2 = 0x41; // store a long value in a local variable 2
    public static final int lstore_3 = 0x42; // store a long value in a local variable 3
    public static final int lsub = 0x65; // subtract two longs
    public static final int lushr = 0x7d; // bitwise shift right of a long value1 by int value2 positions, unsigned
    public static final int lxor = 0x83; // bitwise XOR of two longs
    public static final int monitorenter = 0xc2; // enter monitor for object ("grab the lock" – start of synchronized() section)
    public static final int monitorexit = 0xc3; // exit monitor for object ("release the lock" – end of synchronized() section)
    public static final int multianewarray = 0xc5; // create a new array of dimensions dimensions of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2); the sizes of each dimension is identified by count1, [count2, etc.]
    public static final int _new = 0xbb; // create new object of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2)
    public static final int newarray = 0xbc; // create new array with count elements of primitive type identified by atype
    public static final int nop = 0x00; // perform no operation
    public static final int pop = 0x57; // discard the top value on the stack
    public static final int pop2 = 0x58; // discard the top two values on the stack (or one value, if it is a double or long)
    public static final int putfield = 0xb5; // set field to value in an object objectref, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    public static final int putstatic = 0xb3; // set static field to value in a class, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    public static final int ret = 0xa9; // continue execution from address taken from a local variable #index (the asymmetry with jsr is intentional)
    public static final int _return = 0xb1; // return void from method
    public static final int saload = 0x35; // load short from array
    public static final int sastore = 0x56; // store short to array
    public static final int sipush = 0x11; // push a short onto the stack as an integer value
    public static final int swap = 0x5f; // swaps two top words on the stack (note that value1 and value2 must not be double or long)
    public static final int tableswitch = 0xaa; // continue execution from an address in the table at offset index
    public static final int wide = 0xc4; // execute opcode, where opcode is either iload, fload, aload, lload, dload, istore, fstore, astore, lstore, dstore, or ret, but assume the index is 16 bit; or execute iinc, where the index is 16 bits and the constant to increment by is a signed 16 bit short
}
